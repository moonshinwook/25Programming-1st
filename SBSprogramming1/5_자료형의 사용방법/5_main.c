#include  <stdio.h>
#include  <stdint.h> 

int main()
{
	printf("5강 시작!\n");

	// 정수, 실수 구분해야 한다.
	// 메모리의 크기를 지정할 수 있다. 
	// sizeof
	// 정수 형태의 자료형들 char, short, int, long, long long
	// 1바이트의 크기를 저장할 수 있고 데이터를 읽는 방식은 정수다 + 이름은 number1;
	// 
	char number1;	// number1 char자료 형태로 데이터를 저장할 수 있게 (변수 선언).
	short number2;
	int number3;
	long number4;
	long long number5;

	printf("char자료형의 크기 : %llu\n", sizeof(char)); // 바이트의 크기 
	printf("short자료형의 크기 : %llu\n", sizeof(short));
	printf("int자료형의 크기 : %llu\n", sizeof(int));
	printf("long자료형의 크기 : %llu\n", sizeof(long));
	printf("long long자료형의 크기 : %llu\n", sizeof(long long));

	// int, long 같은 크기의 자료형을 선언했을까?
	// 자료형 최소 ~ 최대 크기가 지정이 되어있다. 
	// 컴파일러 자료형의 크기가 다르다. 

	int16_t num1 = 1;	// 8 x 2 = 2바이트
	int32_t num2 = 1;	// 8 x 4
	int64_t num3 = 1;	// 8 x 8
	printf("int16_t자료형의 크기 : %llu\n", sizeof(int16_t));
	printf("int32_t자료형의 크기 : %llu\n", sizeof(int32_t));
	printf("int64_t자료형의 크기 : %llu\n", sizeof(int64_t));

	// 오버플로우
	// 부호가 있는 정수, 부호가 없는 정수 => MSB 0, 1 (0 양수, 1 음수)
	// unsigned << 양수만 표현하겠다. 2^7 -> 2^8 128양의 정수 더 표현할 수 있다. 
	// 레벨 데이터 표현. 정수형태의 자료형 선책하고 싶다. char, short, int, long, long long 

	// 레벨 데이터 저장해둘건데, 어떤 데이터 타입으로 설정하는게 가장 효과적일까? 
	// int -> 21억, 충분한 공간을 확보할 수 있다. 
	// 최대 레벨 존재. 999,999 -> 적은 크기의 데이터를 저장하는데 불필요한 공간을 사용할 수 있다.
	// 확장이 될 수 있다. 21억 큰 숫자를 표현하게 될 수 있지 않을까
	// 데미지. 9999억, 21억		2^4x8
	// 2^64 -> 숫자 단위에 맞게끔 표현해야 하는가? 조 -> 1$

	char level = 1;	// 0000 0001 
	printf("현재 레벨 : %d\n", level);
	level = 1 + 128; // 0111 1111 127 // 1000 0000 0000 0000
	printf("현재 레벨 : %d\n", level);
	unsigned char level2 = 1; // 0 ~ 최대 값. 42억.

	// 음수를 표현하는 방법 고찰. 

	// 1110001(2) 이진수
	// 12345678	  십진수 -> 8x1 +7 x 10 +6 x 10^2 ...
	// 1(마지막 자리는 부호)111111(2) 2^0 x 1 + 2^1x1 + 

	// 부호를 표현하는 숫자만 0, 1 2진법 나머지를 표현해보자. 
	// -5 비트로 표현을 하고 싶다. 1000101 => 4 + 1 = 5 ->
	// 5 + (-5) = 0
	// 1000101 [-5]
	// 0000101 [5]
	// 1001010 [-10] 5-5 = -10
	// 두 수를 더하면 0이 되어야한다. 
	// 0000101
	// 1111010
	// 1111111 + 1 (음수 표현법) 
	//1 0000 0000
	// 비트를 모두 반대로 변환하고 1을 더해준다. => 2의 보수법

	// 2바이트 short 9 [0000 0000][0000 0001]	1
	//				   [1111 1111][1111 1111]	-1
	 
	// 소수점이 없는 숫자를 표현하였습니다.
	// float, double, long double

	float n1 = 0.00123f;	// 4바이트
	double n2 = 0.00123f;	// 8바이트
	long double n3 = 0.00123f;
	printf("float의 크기 : %llu\n", sizeof(float));
	printf("double의 크기 : %llu\n", sizeof(double));
	printf("long double의 크기 : %llu\n", sizeof(long double));

	// 4x8 비트 공간에서 실수를 표현하기 위한 방법
	// (정수)소수점(실수)
	// [       정수   ][    소수점   ]     [0][ 7      ] [   ] => 24.4 => 표현할 수 있는 가짓수가 너무 적다. 
	// 1. 00000000000000000125
	// 고정 소수점 
	// float 부동소수점, 둥둥 떠다니다. 

	//1.3 13000 => 1.3 x 10^4 => 진수로 표현하는 로직 => IEEE754(실제 정수값이 컴퓨터에서 가지는 값 표현 사이트)
	// -13000	=> [1][ 몇 승 증가했는가?][유효 숫자는 얼마인가]
	// 0.0123	=> 1.23 x 10^-2
	// -0.0123	=> -1.23 x 10^-2

	// 컴퓨터는 10진수 표기법을 사용하지 않고 2진수 표기법 사용을 한다. 
	// 고정 소수점 : 정확한 소수를 표현할 수 있다, 소수를 표현하기에는 공간이 너무 부족하다.
	// 부동 소수점 : 2^?	 + 유효숫자 표기, 소수점이 정확하지 않다. 
	// 컴퓨터에서 실수를 표현하는 방식은 정확하게 일치하지 않다. 

	// 특정 조건이 만족하면 어떤 코드를 실행해라. 

	float n4 = 0.3f; // 0.300000011920928955078125
	float n5 = 0.4f; // 0.4000000059604644775390625
	float n6 = 0.7f; // 0.699999988079071044921875
	// -> 실제 0.4와 0.3을 컴퓨터가 갖는 값은 우리가 아는 값과 다르다. 

	// 실험실 결과 추론 코드로 결과를 유추할 수 있습니다.
	// 물리현상을 추론하기 위해서 넣어서 시뮬레이션. 
	// 특정 자리수까지만 사용하겠다. -> 오차를 줄일 수 있다.
	// float, double -> 소수점을 표현하는 정확성이 다르다. 
	// 소수점이 명확하게 표현이 되고 있지 않다. 
	// 소수점의 계산을 통해서 특정 결과값을 유추하는 코드는 문제가 있을 수 있다. 
	if (n6 == n4 + n5)
	{
		printf("0.7 = 0.3 + 0.4 같습니다\n");
	}
	else
	{
		printf("0.7 = 0.3 + 0.4 다릅니다\n"); 
	}
	// comment 

	// 문자를 표현하는 방법 

	char character1 = 97;  // 8개  01100001
	short character2 = 97; // 16개 00000000    01100001
	int character3 = 97;   // 32개 [ ] [ ] [ ] 01100001 
	double character4 = 97;// %c 안될까요? 실수를 표현하는 double형태로 표현했기 때문에 다른 결과값이 나옴. 97 =/ 97

	// 똑같은 데이터를 사용하는데 어떻게 사용하느냐에 따라서 결과가 달라진다. 

	printf("%c\n", character1);
	printf("%c\n", character2);	// 문자를 표현 -> 낭비되는 메모리가 있더라
	printf("%c\n", character3);	// 문자를 표현 -> 낭비되는 메모리가 있더라
	// printf("%c\n", character4); character4 97값이 안 들어 있기 때문에 문자를 제대로 표현하지 못했다.  

	// char 문자를 표현하는 타입이다. 
	// 그래서 한글은요?
	// 자음 + 모음 , 자음 + 모음 + 자음/ 모음x
	// 조합형 쓸까? 
	// 완성형 쓸까? 가 -> 특정 숫자에 저장 char -> 128개 저장 가능 -> 한글 표현하기에는 너무 부족.
	// ((히라가나, 가타가나, 한자), 중국(한자)
	// EUC_KR 2350 한글로 표현? -> 펩이 없어서 -> 펲시콜라로 표현 -> CP949(2바이트) 모든 한글을 표현할 수 있도록 대응되도록 만들었습니다. -> 용량이 더 적은 편
	// ANSI 
	// (최신 방식) UTF-8(3바이트) 유니코드, 통일성,
	// [ EUC_KR] 인코딩 되어 코드를 UTF-8 바꾸는 API		
	// 한글을 표현하는 방식에 대해서 조사해보기!	인코딩 000101010(2) 한글로 표현하게 하는 디코딩!

	// 코드의 흐름을 작성 ( 반복문, 조건문)
}